// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Category_tbl.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Category_tbl TABLE
class TableCategory_tbl extends SqfEntityTableBase {
  TableCategory_tbl() {
    // declare properties of EntityTable
    tableName = 'category_tbl';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('title', DbType.text),
      SqfEntityFieldBase('sort', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCategory_tbl();
  }
}

// Habit_tbl TABLE
class TableHabit_tbl extends SqfEntityTableBase {
  TableHabit_tbl() {
    // declare properties of EntityTable
    tableName = 'habit_tbl';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('title', DbType.text),
      SqfEntityFieldBase('mode', DbType.integer),
      SqfEntityFieldBase('icon', DbType.text),
      SqfEntityFieldBase('alarm', DbType.text),
      SqfEntityFieldBase('presetTime', DbType.integer),
      SqfEntityFieldBase('categoryIndex', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableHabit_tbl();
  }
}

// Pause_tbl TABLE
class TablePause_tbl extends SqfEntityTableBase {
  TablePause_tbl() {
    // declare properties of EntityTable
    tableName = 'pause_tbl';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('startTime', DbType.integer),
      SqfEntityFieldBase('endTime', DbType.integer),
      SqfEntityFieldBase('stopwatchIndex', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePause_tbl();
  }
}

// Setting_tbl TABLE
class TableSetting_tbl extends SqfEntityTableBase {
  TableSetting_tbl() {
    // declare properties of EntityTable
    tableName = 'setting_tbl';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('darkMode', DbType.bool),
      SqfEntityFieldBase('opening', DbType.bool),
      SqfEntityFieldBase('timeMode', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSetting_tbl();
  }
}

// Stopwatch_tbl TABLE
class TableStopwatch_tbl extends SqfEntityTableBase {
  TableStopwatch_tbl() {
    // declare properties of EntityTable
    tableName = 'stopwatch_tbl';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('startTime', DbType.integer),
      SqfEntityFieldBase('endTime', DbType.integer),
      SqfEntityFieldBase('habitIndex', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableStopwatch_tbl();
  }
}
// END TABLES

// BEGIN SEQUENCES
// identity SEQUENCE
class SequenceIdentitySequence extends SqfEntitySequenceBase {
  SequenceIdentitySequence() {
    sequenceName = 'identity';
    maxValue =
        9007199254740991; /* optional. default is max int (9.223.372.036.854.775.807) */
    cycle = false; /* optional. default is false; */
    minValue = 0; /* optional. default is 0 */
    incrementBy = 1; /* optional. default is 1 */
    startWith = 0; /* optional. default is 0 */
    super.init();
  }
  static SequenceIdentitySequence? _instance;
  static SequenceIdentitySequence get getInstance {
    return _instance = _instance ?? SequenceIdentitySequence();
  }
}
// END SEQUENCES

// BEGIN DATABASE MODEL
class SPEND_TIME extends SqfEntityModelProvider {
  SPEND_TIME() {
    databaseName = db.databaseName;
    password = db.password;
    dbVersion = db.dbVersion;
    preSaveAction = db.preSaveAction;
    logFunction = db.logFunction;
    databaseTables = [
      TableCategory_tbl.getInstance,
      TableHabit_tbl.getInstance,
      TablePause_tbl.getInstance,
      TableSetting_tbl.getInstance,
      TableStopwatch_tbl.getInstance,
    ];

    sequences = [
      SequenceIdentitySequence.getInstance,
    ];

    bundledDatabasePath = db
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = db.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Category_tbl
class Category_tbl extends TableBase {
  Category_tbl({this.id, this.title, this.sort}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Category_tbl.withFields(this.title, this.sort) {
    _setDefaultValues();
  }
  Category_tbl.withId(this.id, this.title, this.sort) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Category_tbl.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['title'] != null) {
      title = o['title'].toString();
    }
    if (o['sort'] != null) {
      sort = int.tryParse(o['sort'].toString());
    }
  }
  // FIELDS (Category_tbl)
  int? id;
  String? title;
  int? sort;

  // end FIELDS (Category_tbl)

  static const bool _softDeleteActivated = false;
  Category_tblManager? __mnCategory_tbl;

  Category_tblManager get _mnCategory_tbl {
    return __mnCategory_tbl = __mnCategory_tbl ?? Category_tblManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (sort != null || !forView) {
      map['sort'] = sort;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (sort != null || !forView) {
      map['sort'] = sort;
    }

    return map;
  }

  /// This method returns Json String [Category_tbl]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Category_tbl]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [title, sort];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, title, sort];
  }

  static Future<List<Category_tbl>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Category_tbl.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Category_tbl>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Category_tbl>[];
    try {
      objList = list
          .map((category_tbl) =>
              Category_tbl.fromMap(category_tbl as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Category_tbl.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Category_tbl>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Category_tbl> objList = <Category_tbl>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Category_tbl.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Category_tbl by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Category_tbl] if exist, otherwise returns null
  Future<Category_tbl?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Category_tbl? obj;
    final data = await _mnCategory_tbl.getById([id]);
    if (data.length != 0) {
      obj = Category_tbl.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Category_tbl) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCategory_tbl.insert(this, ignoreBatch);
    } else {
      await _mnCategory_tbl.update(this);
    }

    return id;
  }

  /// Saves the (Category_tbl) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCategory_tbl.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCategory_tbl.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Category_tbl. Returns a new Primary Key value of Category_tbl

  /// <returns>Returns a new Primary Key value of Category_tbl
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Category_tbl> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Category_tbl> category_tbls,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SPEND_TIME().batchStart();
    for (final obj in category_tbls) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SPEND_TIME().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < category_tbls.length; i++) {
        if (category_tbls[i].id == null) {
          category_tbls[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCategory_tbl.rawInsert(
          'INSERT OR REPLACE INTO category_tbl (id, title, sort)  VALUES (?,?,?)',
          [id, title, sort],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Category_tbl id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Category_tbl id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Category_tbl Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Category_tbl>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Category_tbl> category_tbls,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnCategory_tbl.rawInsertAll(
        'INSERT OR REPLACE INTO category_tbl (id, title, sort)  VALUES (?,?,?)',
        category_tbls,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Category_tbl

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Category_tbl invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCategory_tbl
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnCategory_tbl.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Category_tbl] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Category_tblFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Category_tblFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Category_tblFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Category_tblFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion category_tbl

// region Category_tblField
class Category_tblField extends FilterBase {
  Category_tblField(Category_tblFilterBuilder category_tblFB)
      : super(category_tblFB);

  @override
  Category_tblFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder isNull() {
    return super.isNull() as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Category_tblFilterBuilder;
  }

  @override
  Category_tblFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Category_tblFilterBuilder;
  }

  @override
  Category_tblField get not {
    return super.not as Category_tblField;
  }
}
// endregion Category_tblField

// region Category_tblFilterBuilder
class Category_tblFilterBuilder extends ConjunctionBase {
  Category_tblFilterBuilder(Category_tbl obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCategory_tbl = obj._mnCategory_tbl;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Category_tblManager? _mnCategory_tbl;

  /// put the sql keyword 'AND'
  @override
  Category_tblFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Category_tblFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Category_tblFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Category_tblFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Category_tblFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Category_tblFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Category_tblFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Category_tblFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Category_tblFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Category_tblFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Category_tblFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Category_tblField _setField(
      Category_tblField? field, String colName, DbType dbtype) {
    return Category_tblField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Category_tblField? _id;
  Category_tblField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  Category_tblField? _title;
  Category_tblField get title {
    return _title = _setField(_title, 'title', DbType.text);
  }

  Category_tblField? _sort;
  Category_tblField get sort {
    return _sort = _setField(_sort, 'sort', DbType.integer);
  }

  /// Deletes List<Category_tbl> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCategory_tbl!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCategory_tbl!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from category_tbl ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCategory_tbl!.updateBatch(qparams, values);
  }

  /// This method always returns [Category_tbl] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Category_tbl?
  @override
  Future<Category_tbl?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCategory_tbl!.toList(qparams);
    final data = await objFuture;
    Category_tbl? obj;
    if (data.isNotEmpty) {
      obj = Category_tbl.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Category_tbl]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Category_tbl?
  @override
  Future<Category_tbl> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Category_tbl();
  }

  /// This method returns int. [Category_tbl]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? category_tblCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final category_tblsFuture = await _mnCategory_tbl!.toList(qparams);
    final int count = category_tblsFuture[0]['CNT'] as int;
    if (category_tblCount != null) {
      category_tblCount(count);
    }
    return count;
  }

  /// This method returns List<Category_tbl> [Category_tbl]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Category_tbl>
  @override
  Future<List<Category_tbl>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Category_tbl> category_tblsData = await Category_tbl.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return category_tblsData;
  }

  /// This method returns Json String [Category_tbl]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Category_tbl]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Category_tbl]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCategory_tbl!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Category_tbl]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM category_tbl WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnCategory_tbl!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Category_tbl]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCategory_tbl!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Category_tbl.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCategory_tbl!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Category_tblFilterBuilder

// region Category_tblFields
class Category_tblFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fTitle;
  static TableField get title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'title', DbType.text);
  }

  static TableField? _fSort;
  static TableField get sort {
    return _fSort =
        _fSort ?? SqlSyntax.setField(_fSort, 'sort', DbType.integer);
  }
}
// endregion Category_tblFields

//region Category_tblManager
class Category_tblManager extends SqfEntityProvider {
  Category_tblManager()
      : super(SPEND_TIME(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'category_tbl';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion Category_tblManager
// region Habit_tbl
class Habit_tbl extends TableBase {
  Habit_tbl(
      {this.id,
      this.title,
      this.mode,
      this.icon,
      this.alarm,
      this.presetTime,
      this.categoryIndex}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Habit_tbl.withFields(this.title, this.mode, this.icon, this.alarm,
      this.presetTime, this.categoryIndex) {
    _setDefaultValues();
  }
  Habit_tbl.withId(this.id, this.title, this.mode, this.icon, this.alarm,
      this.presetTime, this.categoryIndex) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Habit_tbl.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['title'] != null) {
      title = o['title'].toString();
    }
    if (o['mode'] != null) {
      mode = int.tryParse(o['mode'].toString());
    }
    if (o['icon'] != null) {
      icon = o['icon'].toString();
    }
    if (o['alarm'] != null) {
      alarm = o['alarm'].toString();
    }
    if (o['presetTime'] != null) {
      presetTime = int.tryParse(o['presetTime'].toString());
    }
    if (o['categoryIndex'] != null) {
      categoryIndex = int.tryParse(o['categoryIndex'].toString());
    }
  }
  // FIELDS (Habit_tbl)
  int? id;
  String? title;
  int? mode;
  String? icon;
  String? alarm;
  int? presetTime;
  int? categoryIndex;

  // end FIELDS (Habit_tbl)

  static const bool _softDeleteActivated = false;
  Habit_tblManager? __mnHabit_tbl;

  Habit_tblManager get _mnHabit_tbl {
    return __mnHabit_tbl = __mnHabit_tbl ?? Habit_tblManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (mode != null || !forView) {
      map['mode'] = mode;
    }
    if (icon != null || !forView) {
      map['icon'] = icon;
    }
    if (alarm != null || !forView) {
      map['alarm'] = alarm;
    }
    if (presetTime != null || !forView) {
      map['presetTime'] = presetTime;
    }
    if (categoryIndex != null || !forView) {
      map['categoryIndex'] = categoryIndex;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (mode != null || !forView) {
      map['mode'] = mode;
    }
    if (icon != null || !forView) {
      map['icon'] = icon;
    }
    if (alarm != null || !forView) {
      map['alarm'] = alarm;
    }
    if (presetTime != null || !forView) {
      map['presetTime'] = presetTime;
    }
    if (categoryIndex != null || !forView) {
      map['categoryIndex'] = categoryIndex;
    }

    return map;
  }

  /// This method returns Json String [Habit_tbl]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Habit_tbl]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [title, mode, icon, alarm, presetTime, categoryIndex];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, title, mode, icon, alarm, presetTime, categoryIndex];
  }

  static Future<List<Habit_tbl>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Habit_tbl.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Habit_tbl>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Habit_tbl>[];
    try {
      objList = list
          .map((habit_tbl) =>
              Habit_tbl.fromMap(habit_tbl as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Habit_tbl.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Habit_tbl>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Habit_tbl> objList = <Habit_tbl>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Habit_tbl.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Habit_tbl by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Habit_tbl] if exist, otherwise returns null
  Future<Habit_tbl?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Habit_tbl? obj;
    final data = await _mnHabit_tbl.getById([id]);
    if (data.length != 0) {
      obj = Habit_tbl.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Habit_tbl) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnHabit_tbl.insert(this, ignoreBatch);
    } else {
      await _mnHabit_tbl.update(this);
    }

    return id;
  }

  /// Saves the (Habit_tbl) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnHabit_tbl.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnHabit_tbl.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Habit_tbl. Returns a new Primary Key value of Habit_tbl

  /// <returns>Returns a new Primary Key value of Habit_tbl
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Habit_tbl> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Habit_tbl> habit_tbls,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SPEND_TIME().batchStart();
    for (final obj in habit_tbls) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SPEND_TIME().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < habit_tbls.length; i++) {
        if (habit_tbls[i].id == null) {
          habit_tbls[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnHabit_tbl.rawInsert(
          'INSERT OR REPLACE INTO habit_tbl (id, title, mode, icon, alarm, presetTime, categoryIndex)  VALUES (?,?,?,?,?,?,?)',
          [id, title, mode, icon, alarm, presetTime, categoryIndex],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Habit_tbl id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Habit_tbl id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Habit_tbl Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Habit_tbl>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Habit_tbl> habit_tbls,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnHabit_tbl.rawInsertAll(
        'INSERT OR REPLACE INTO habit_tbl (id, title, mode, icon, alarm, presetTime, categoryIndex)  VALUES (?,?,?,?,?,?,?)',
        habit_tbls,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Habit_tbl

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Habit_tbl invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnHabit_tbl
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnHabit_tbl.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Habit_tbl] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Habit_tblFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Habit_tblFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Habit_tblFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Habit_tblFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion habit_tbl

// region Habit_tblField
class Habit_tblField extends FilterBase {
  Habit_tblField(Habit_tblFilterBuilder habit_tblFB) : super(habit_tblFB);

  @override
  Habit_tblFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder isNull() {
    return super.isNull() as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Habit_tblFilterBuilder;
  }

  @override
  Habit_tblField get not {
    return super.not as Habit_tblField;
  }
}
// endregion Habit_tblField

// region Habit_tblFilterBuilder
class Habit_tblFilterBuilder extends ConjunctionBase {
  Habit_tblFilterBuilder(Habit_tbl obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnHabit_tbl = obj._mnHabit_tbl;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Habit_tblManager? _mnHabit_tbl;

  /// put the sql keyword 'AND'
  @override
  Habit_tblFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Habit_tblFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Habit_tblFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Habit_tblFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Habit_tblFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Habit_tblFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Habit_tblFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Habit_tblFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Habit_tblFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Habit_tblFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Habit_tblFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Habit_tblField _setField(
      Habit_tblField? field, String colName, DbType dbtype) {
    return Habit_tblField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Habit_tblField? _id;
  Habit_tblField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  Habit_tblField? _title;
  Habit_tblField get title {
    return _title = _setField(_title, 'title', DbType.text);
  }

  Habit_tblField? _mode;
  Habit_tblField get mode {
    return _mode = _setField(_mode, 'mode', DbType.integer);
  }

  Habit_tblField? _icon;
  Habit_tblField get icon {
    return _icon = _setField(_icon, 'icon', DbType.text);
  }

  Habit_tblField? _alarm;
  Habit_tblField get alarm {
    return _alarm = _setField(_alarm, 'alarm', DbType.text);
  }

  Habit_tblField? _presetTime;
  Habit_tblField get presetTime {
    return _presetTime = _setField(_presetTime, 'presetTime', DbType.integer);
  }

  Habit_tblField? _categoryIndex;
  Habit_tblField get categoryIndex {
    return _categoryIndex =
        _setField(_categoryIndex, 'categoryIndex', DbType.integer);
  }

  /// Deletes List<Habit_tbl> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnHabit_tbl!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnHabit_tbl!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from habit_tbl ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnHabit_tbl!.updateBatch(qparams, values);
  }

  /// This method always returns [Habit_tbl] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Habit_tbl?
  @override
  Future<Habit_tbl?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnHabit_tbl!.toList(qparams);
    final data = await objFuture;
    Habit_tbl? obj;
    if (data.isNotEmpty) {
      obj = Habit_tbl.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Habit_tbl]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Habit_tbl?
  @override
  Future<Habit_tbl> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Habit_tbl();
  }

  /// This method returns int. [Habit_tbl]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? habit_tblCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final habit_tblsFuture = await _mnHabit_tbl!.toList(qparams);
    final int count = habit_tblsFuture[0]['CNT'] as int;
    if (habit_tblCount != null) {
      habit_tblCount(count);
    }
    return count;
  }

  /// This method returns List<Habit_tbl> [Habit_tbl]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Habit_tbl>
  @override
  Future<List<Habit_tbl>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Habit_tbl> habit_tblsData = await Habit_tbl.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return habit_tblsData;
  }

  /// This method returns Json String [Habit_tbl]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Habit_tbl]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Habit_tbl]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnHabit_tbl!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Habit_tbl]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM habit_tbl WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnHabit_tbl!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Habit_tbl]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnHabit_tbl!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Habit_tbl.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnHabit_tbl!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Habit_tblFilterBuilder

// region Habit_tblFields
class Habit_tblFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fTitle;
  static TableField get title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'title', DbType.text);
  }

  static TableField? _fMode;
  static TableField get mode {
    return _fMode =
        _fMode ?? SqlSyntax.setField(_fMode, 'mode', DbType.integer);
  }

  static TableField? _fIcon;
  static TableField get icon {
    return _fIcon = _fIcon ?? SqlSyntax.setField(_fIcon, 'icon', DbType.text);
  }

  static TableField? _fAlarm;
  static TableField get alarm {
    return _fAlarm =
        _fAlarm ?? SqlSyntax.setField(_fAlarm, 'alarm', DbType.text);
  }

  static TableField? _fPresetTime;
  static TableField get presetTime {
    return _fPresetTime = _fPresetTime ??
        SqlSyntax.setField(_fPresetTime, 'presetTime', DbType.integer);
  }

  static TableField? _fCategoryIndex;
  static TableField get categoryIndex {
    return _fCategoryIndex = _fCategoryIndex ??
        SqlSyntax.setField(_fCategoryIndex, 'categoryIndex', DbType.integer);
  }
}
// endregion Habit_tblFields

//region Habit_tblManager
class Habit_tblManager extends SqfEntityProvider {
  Habit_tblManager()
      : super(SPEND_TIME(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'habit_tbl';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion Habit_tblManager
// region Pause_tbl
class Pause_tbl extends TableBase {
  Pause_tbl({this.id, this.startTime, this.endTime, this.stopwatchIndex}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Pause_tbl.withFields(this.startTime, this.endTime, this.stopwatchIndex) {
    _setDefaultValues();
  }
  Pause_tbl.withId(this.id, this.startTime, this.endTime, this.stopwatchIndex) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Pause_tbl.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['startTime'] != null) {
      startTime = int.tryParse(o['startTime'].toString());
    }
    if (o['endTime'] != null) {
      endTime = int.tryParse(o['endTime'].toString());
    }
    if (o['stopwatchIndex'] != null) {
      stopwatchIndex = int.tryParse(o['stopwatchIndex'].toString());
    }
  }
  // FIELDS (Pause_tbl)
  int? id;
  int? startTime;
  int? endTime;
  int? stopwatchIndex;

  // end FIELDS (Pause_tbl)

  static const bool _softDeleteActivated = false;
  Pause_tblManager? __mnPause_tbl;

  Pause_tblManager get _mnPause_tbl {
    return __mnPause_tbl = __mnPause_tbl ?? Pause_tblManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (startTime != null || !forView) {
      map['startTime'] = startTime;
    }
    if (endTime != null || !forView) {
      map['endTime'] = endTime;
    }
    if (stopwatchIndex != null || !forView) {
      map['stopwatchIndex'] = stopwatchIndex;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (startTime != null || !forView) {
      map['startTime'] = startTime;
    }
    if (endTime != null || !forView) {
      map['endTime'] = endTime;
    }
    if (stopwatchIndex != null || !forView) {
      map['stopwatchIndex'] = stopwatchIndex;
    }

    return map;
  }

  /// This method returns Json String [Pause_tbl]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Pause_tbl]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [startTime, endTime, stopwatchIndex];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, startTime, endTime, stopwatchIndex];
  }

  static Future<List<Pause_tbl>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Pause_tbl.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Pause_tbl>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Pause_tbl>[];
    try {
      objList = list
          .map((pause_tbl) =>
              Pause_tbl.fromMap(pause_tbl as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Pause_tbl.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Pause_tbl>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Pause_tbl> objList = <Pause_tbl>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Pause_tbl.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Pause_tbl by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Pause_tbl] if exist, otherwise returns null
  Future<Pause_tbl?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Pause_tbl? obj;
    final data = await _mnPause_tbl.getById([id]);
    if (data.length != 0) {
      obj = Pause_tbl.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Pause_tbl) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPause_tbl.insert(this, ignoreBatch);
    } else {
      await _mnPause_tbl.update(this);
    }

    return id;
  }

  /// Saves the (Pause_tbl) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPause_tbl.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPause_tbl.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Pause_tbl. Returns a new Primary Key value of Pause_tbl

  /// <returns>Returns a new Primary Key value of Pause_tbl
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Pause_tbl> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Pause_tbl> pause_tbls,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SPEND_TIME().batchStart();
    for (final obj in pause_tbls) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SPEND_TIME().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < pause_tbls.length; i++) {
        if (pause_tbls[i].id == null) {
          pause_tbls[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPause_tbl.rawInsert(
          'INSERT OR REPLACE INTO pause_tbl (id, startTime, endTime, stopwatchIndex)  VALUES (?,?,?,?)',
          [id, startTime, endTime, stopwatchIndex],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Pause_tbl id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Pause_tbl id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Pause_tbl Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Pause_tbl>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Pause_tbl> pause_tbls,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnPause_tbl.rawInsertAll(
        'INSERT OR REPLACE INTO pause_tbl (id, startTime, endTime, stopwatchIndex)  VALUES (?,?,?,?)',
        pause_tbls,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Pause_tbl

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Pause_tbl invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPause_tbl
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPause_tbl.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Pause_tbl] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Pause_tblFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Pause_tblFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Pause_tblFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Pause_tblFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion pause_tbl

// region Pause_tblField
class Pause_tblField extends FilterBase {
  Pause_tblField(Pause_tblFilterBuilder pause_tblFB) : super(pause_tblFB);

  @override
  Pause_tblFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder isNull() {
    return super.isNull() as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Pause_tblFilterBuilder;
  }

  @override
  Pause_tblField get not {
    return super.not as Pause_tblField;
  }
}
// endregion Pause_tblField

// region Pause_tblFilterBuilder
class Pause_tblFilterBuilder extends ConjunctionBase {
  Pause_tblFilterBuilder(Pause_tbl obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPause_tbl = obj._mnPause_tbl;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Pause_tblManager? _mnPause_tbl;

  /// put the sql keyword 'AND'
  @override
  Pause_tblFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Pause_tblFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Pause_tblFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Pause_tblFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Pause_tblFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Pause_tblFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Pause_tblFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Pause_tblFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Pause_tblFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Pause_tblFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Pause_tblFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Pause_tblField _setField(
      Pause_tblField? field, String colName, DbType dbtype) {
    return Pause_tblField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Pause_tblField? _id;
  Pause_tblField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  Pause_tblField? _startTime;
  Pause_tblField get startTime {
    return _startTime = _setField(_startTime, 'startTime', DbType.integer);
  }

  Pause_tblField? _endTime;
  Pause_tblField get endTime {
    return _endTime = _setField(_endTime, 'endTime', DbType.integer);
  }

  Pause_tblField? _stopwatchIndex;
  Pause_tblField get stopwatchIndex {
    return _stopwatchIndex =
        _setField(_stopwatchIndex, 'stopwatchIndex', DbType.integer);
  }

  /// Deletes List<Pause_tbl> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPause_tbl!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPause_tbl!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from pause_tbl ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPause_tbl!.updateBatch(qparams, values);
  }

  /// This method always returns [Pause_tbl] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Pause_tbl?
  @override
  Future<Pause_tbl?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPause_tbl!.toList(qparams);
    final data = await objFuture;
    Pause_tbl? obj;
    if (data.isNotEmpty) {
      obj = Pause_tbl.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Pause_tbl]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Pause_tbl?
  @override
  Future<Pause_tbl> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Pause_tbl();
  }

  /// This method returns int. [Pause_tbl]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? pause_tblCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final pause_tblsFuture = await _mnPause_tbl!.toList(qparams);
    final int count = pause_tblsFuture[0]['CNT'] as int;
    if (pause_tblCount != null) {
      pause_tblCount(count);
    }
    return count;
  }

  /// This method returns List<Pause_tbl> [Pause_tbl]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Pause_tbl>
  @override
  Future<List<Pause_tbl>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Pause_tbl> pause_tblsData = await Pause_tbl.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return pause_tblsData;
  }

  /// This method returns Json String [Pause_tbl]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Pause_tbl]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Pause_tbl]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPause_tbl!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Pause_tbl]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM pause_tbl WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnPause_tbl!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Pause_tbl]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPause_tbl!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Pause_tbl.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPause_tbl!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Pause_tblFilterBuilder

// region Pause_tblFields
class Pause_tblFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fStartTime;
  static TableField get startTime {
    return _fStartTime = _fStartTime ??
        SqlSyntax.setField(_fStartTime, 'startTime', DbType.integer);
  }

  static TableField? _fEndTime;
  static TableField get endTime {
    return _fEndTime =
        _fEndTime ?? SqlSyntax.setField(_fEndTime, 'endTime', DbType.integer);
  }

  static TableField? _fStopwatchIndex;
  static TableField get stopwatchIndex {
    return _fStopwatchIndex = _fStopwatchIndex ??
        SqlSyntax.setField(_fStopwatchIndex, 'stopwatchIndex', DbType.integer);
  }
}
// endregion Pause_tblFields

//region Pause_tblManager
class Pause_tblManager extends SqfEntityProvider {
  Pause_tblManager()
      : super(SPEND_TIME(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'pause_tbl';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion Pause_tblManager
// region Setting_tbl
class Setting_tbl extends TableBase {
  Setting_tbl({this.id, this.darkMode, this.opening, this.timeMode}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Setting_tbl.withFields(this.id, this.darkMode, this.opening, this.timeMode) {
    _setDefaultValues();
  }
  Setting_tbl.withId(this.id, this.darkMode, this.opening, this.timeMode) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Setting_tbl.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['darkMode'] != null) {
      darkMode =
          o['darkMode'].toString() == '1' || o['darkMode'].toString() == 'true';
    }
    if (o['opening'] != null) {
      opening =
          o['opening'].toString() == '1' || o['opening'].toString() == 'true';
    }
    if (o['timeMode'] != null) {
      timeMode = int.tryParse(o['timeMode'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Setting_tbl)
  int? id;
  bool? darkMode;
  bool? opening;
  int? timeMode;
  bool? isSaved;
  // end FIELDS (Setting_tbl)

  static const bool _softDeleteActivated = false;
  Setting_tblManager? __mnSetting_tbl;

  Setting_tblManager get _mnSetting_tbl {
    return __mnSetting_tbl = __mnSetting_tbl ?? Setting_tblManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (darkMode != null) {
      map['darkMode'] = forQuery ? (darkMode! ? 1 : 0) : darkMode;
    } else if (darkMode != null || !forView) {
      map['darkMode'] = null;
    }
    if (opening != null) {
      map['opening'] = forQuery ? (opening! ? 1 : 0) : opening;
    } else if (opening != null || !forView) {
      map['opening'] = null;
    }
    if (timeMode != null || !forView) {
      map['timeMode'] = timeMode;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (darkMode != null) {
      map['darkMode'] = forQuery ? (darkMode! ? 1 : 0) : darkMode;
    } else if (darkMode != null || !forView) {
      map['darkMode'] = null;
    }
    if (opening != null) {
      map['opening'] = forQuery ? (opening! ? 1 : 0) : opening;
    } else if (opening != null || !forView) {
      map['opening'] = null;
    }
    if (timeMode != null || !forView) {
      map['timeMode'] = timeMode;
    }

    return map;
  }

  /// This method returns Json String [Setting_tbl]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Setting_tbl]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, darkMode, opening, timeMode];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, darkMode, opening, timeMode];
  }

  static Future<List<Setting_tbl>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Setting_tbl.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Setting_tbl>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Setting_tbl>[];
    try {
      objList = list
          .map((setting_tbl) =>
              Setting_tbl.fromMap(setting_tbl as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Setting_tbl.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Setting_tbl>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Setting_tbl> objList = <Setting_tbl>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Setting_tbl.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Setting_tbl by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Setting_tbl] if exist, otherwise returns null
  Future<Setting_tbl?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Setting_tbl? obj;
    final data = await _mnSetting_tbl.getById([id]);
    if (data.length != 0) {
      obj = Setting_tbl.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Setting_tbl) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSetting_tbl.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnSetting_tbl.update(this);
    }

    return id;
  }

  /// Saves the (Setting_tbl) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSetting_tbl.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSetting_tbl.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Setting_tbl> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Setting_tbl> setting_tbls,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SPEND_TIME().batchStart();
    for (final obj in setting_tbls) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SPEND_TIME().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSetting_tbl.rawInsert(
          'INSERT OR REPLACE INTO setting_tbl (id, darkMode, opening, timeMode)  VALUES (?,?,?,?)',
          [id, darkMode, opening, timeMode],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Setting_tbl id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Setting_tbl id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Setting_tbl Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Setting_tbl>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Setting_tbl> setting_tbls,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnSetting_tbl.rawInsertAll(
        'INSERT OR REPLACE INTO setting_tbl (id, darkMode, opening, timeMode)  VALUES (?,?,?,?)',
        setting_tbls,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Setting_tbl

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Setting_tbl invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSetting_tbl
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSetting_tbl.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Setting_tbl] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Setting_tblFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Setting_tblFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Setting_tblFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Setting_tblFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion setting_tbl

// region Setting_tblField
class Setting_tblField extends FilterBase {
  Setting_tblField(Setting_tblFilterBuilder setting_tblFB)
      : super(setting_tblFB);

  @override
  Setting_tblFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder isNull() {
    return super.isNull() as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Setting_tblFilterBuilder;
  }

  @override
  Setting_tblField get not {
    return super.not as Setting_tblField;
  }
}
// endregion Setting_tblField

// region Setting_tblFilterBuilder
class Setting_tblFilterBuilder extends ConjunctionBase {
  Setting_tblFilterBuilder(Setting_tbl obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSetting_tbl = obj._mnSetting_tbl;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Setting_tblManager? _mnSetting_tbl;

  /// put the sql keyword 'AND'
  @override
  Setting_tblFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Setting_tblFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Setting_tblFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Setting_tblFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Setting_tblFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Setting_tblFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Setting_tblFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Setting_tblFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Setting_tblFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Setting_tblFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Setting_tblFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Setting_tblField _setField(
      Setting_tblField? field, String colName, DbType dbtype) {
    return Setting_tblField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Setting_tblField? _id;
  Setting_tblField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  Setting_tblField? _darkMode;
  Setting_tblField get darkMode {
    return _darkMode = _setField(_darkMode, 'darkMode', DbType.bool);
  }

  Setting_tblField? _opening;
  Setting_tblField get opening {
    return _opening = _setField(_opening, 'opening', DbType.bool);
  }

  Setting_tblField? _timeMode;
  Setting_tblField get timeMode {
    return _timeMode = _setField(_timeMode, 'timeMode', DbType.integer);
  }

  /// Deletes List<Setting_tbl> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSetting_tbl!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSetting_tbl!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from setting_tbl ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSetting_tbl!.updateBatch(qparams, values);
  }

  /// This method always returns [Setting_tbl] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Setting_tbl?
  @override
  Future<Setting_tbl?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSetting_tbl!.toList(qparams);
    final data = await objFuture;
    Setting_tbl? obj;
    if (data.isNotEmpty) {
      obj = Setting_tbl.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Setting_tbl]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Setting_tbl?
  @override
  Future<Setting_tbl> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Setting_tbl();
  }

  /// This method returns int. [Setting_tbl]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? setting_tblCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final setting_tblsFuture = await _mnSetting_tbl!.toList(qparams);
    final int count = setting_tblsFuture[0]['CNT'] as int;
    if (setting_tblCount != null) {
      setting_tblCount(count);
    }
    return count;
  }

  /// This method returns List<Setting_tbl> [Setting_tbl]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Setting_tbl>
  @override
  Future<List<Setting_tbl>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Setting_tbl> setting_tblsData = await Setting_tbl.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return setting_tblsData;
  }

  /// This method returns Json String [Setting_tbl]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Setting_tbl]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Setting_tbl]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSetting_tbl!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Setting_tbl]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM setting_tbl WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSetting_tbl!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Setting_tbl]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSetting_tbl!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Setting_tbl.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSetting_tbl!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Setting_tblFilterBuilder

// region Setting_tblFields
class Setting_tblFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fDarkMode;
  static TableField get darkMode {
    return _fDarkMode =
        _fDarkMode ?? SqlSyntax.setField(_fDarkMode, 'darkMode', DbType.bool);
  }

  static TableField? _fOpening;
  static TableField get opening {
    return _fOpening =
        _fOpening ?? SqlSyntax.setField(_fOpening, 'opening', DbType.bool);
  }

  static TableField? _fTimeMode;
  static TableField get timeMode {
    return _fTimeMode = _fTimeMode ??
        SqlSyntax.setField(_fTimeMode, 'timeMode', DbType.integer);
  }
}
// endregion Setting_tblFields

//region Setting_tblManager
class Setting_tblManager extends SqfEntityProvider {
  Setting_tblManager()
      : super(SPEND_TIME(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'setting_tbl';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion Setting_tblManager
// region Stopwatch_tbl
class Stopwatch_tbl extends TableBase {
  Stopwatch_tbl({this.id, this.startTime, this.endTime, this.habitIndex}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Stopwatch_tbl.withFields(this.startTime, this.endTime, this.habitIndex) {
    _setDefaultValues();
  }
  Stopwatch_tbl.withId(this.id, this.startTime, this.endTime, this.habitIndex) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Stopwatch_tbl.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['startTime'] != null) {
      startTime = int.tryParse(o['startTime'].toString());
    }
    if (o['endTime'] != null) {
      endTime = int.tryParse(o['endTime'].toString());
    }
    if (o['habitIndex'] != null) {
      habitIndex = int.tryParse(o['habitIndex'].toString());
    }
  }
  // FIELDS (Stopwatch_tbl)
  int? id;
  int? startTime;
  int? endTime;
  int? habitIndex;

  // end FIELDS (Stopwatch_tbl)

  static const bool _softDeleteActivated = false;
  Stopwatch_tblManager? __mnStopwatch_tbl;

  Stopwatch_tblManager get _mnStopwatch_tbl {
    return __mnStopwatch_tbl = __mnStopwatch_tbl ?? Stopwatch_tblManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (startTime != null || !forView) {
      map['startTime'] = startTime;
    }
    if (endTime != null || !forView) {
      map['endTime'] = endTime;
    }
    if (habitIndex != null || !forView) {
      map['habitIndex'] = habitIndex;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (startTime != null || !forView) {
      map['startTime'] = startTime;
    }
    if (endTime != null || !forView) {
      map['endTime'] = endTime;
    }
    if (habitIndex != null || !forView) {
      map['habitIndex'] = habitIndex;
    }

    return map;
  }

  /// This method returns Json String [Stopwatch_tbl]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Stopwatch_tbl]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [startTime, endTime, habitIndex];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, startTime, endTime, habitIndex];
  }

  static Future<List<Stopwatch_tbl>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Stopwatch_tbl.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Stopwatch_tbl>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Stopwatch_tbl>[];
    try {
      objList = list
          .map((stopwatch_tbl) =>
              Stopwatch_tbl.fromMap(stopwatch_tbl as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Stopwatch_tbl.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Stopwatch_tbl>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Stopwatch_tbl> objList = <Stopwatch_tbl>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Stopwatch_tbl.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Stopwatch_tbl by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Stopwatch_tbl] if exist, otherwise returns null
  Future<Stopwatch_tbl?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Stopwatch_tbl? obj;
    final data = await _mnStopwatch_tbl.getById([id]);
    if (data.length != 0) {
      obj = Stopwatch_tbl.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Stopwatch_tbl) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnStopwatch_tbl.insert(this, ignoreBatch);
    } else {
      await _mnStopwatch_tbl.update(this);
    }

    return id;
  }

  /// Saves the (Stopwatch_tbl) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnStopwatch_tbl.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnStopwatch_tbl.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Stopwatch_tbl. Returns a new Primary Key value of Stopwatch_tbl

  /// <returns>Returns a new Primary Key value of Stopwatch_tbl
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Stopwatch_tbl> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Stopwatch_tbl> stopwatch_tbls,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await SPEND_TIME().batchStart();
    for (final obj in stopwatch_tbls) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await SPEND_TIME().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < stopwatch_tbls.length; i++) {
        if (stopwatch_tbls[i].id == null) {
          stopwatch_tbls[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnStopwatch_tbl.rawInsert(
          'INSERT OR REPLACE INTO stopwatch_tbl (id, startTime, endTime, habitIndex)  VALUES (?,?,?,?)',
          [id, startTime, endTime, habitIndex],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Stopwatch_tbl id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Stopwatch_tbl id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Stopwatch_tbl Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Stopwatch_tbl>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Stopwatch_tbl> stopwatch_tbls,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnStopwatch_tbl.rawInsertAll(
        'INSERT OR REPLACE INTO stopwatch_tbl (id, startTime, endTime, habitIndex)  VALUES (?,?,?,?)',
        stopwatch_tbls,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Stopwatch_tbl

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Stopwatch_tbl invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnStopwatch_tbl
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnStopwatch_tbl.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Stopwatch_tbl] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Stopwatch_tblFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Stopwatch_tblFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Stopwatch_tblFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Stopwatch_tblFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion stopwatch_tbl

// region Stopwatch_tblField
class Stopwatch_tblField extends FilterBase {
  Stopwatch_tblField(Stopwatch_tblFilterBuilder stopwatch_tblFB)
      : super(stopwatch_tblFB);

  @override
  Stopwatch_tblFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder isNull() {
    return super.isNull() as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Stopwatch_tblFilterBuilder;
  }

  @override
  Stopwatch_tblField get not {
    return super.not as Stopwatch_tblField;
  }
}
// endregion Stopwatch_tblField

// region Stopwatch_tblFilterBuilder
class Stopwatch_tblFilterBuilder extends ConjunctionBase {
  Stopwatch_tblFilterBuilder(Stopwatch_tbl obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnStopwatch_tbl = obj._mnStopwatch_tbl;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Stopwatch_tblManager? _mnStopwatch_tbl;

  /// put the sql keyword 'AND'
  @override
  Stopwatch_tblFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Stopwatch_tblFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Stopwatch_tblFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Stopwatch_tblFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Stopwatch_tblFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Stopwatch_tblFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Stopwatch_tblFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Stopwatch_tblFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Stopwatch_tblFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Stopwatch_tblFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Stopwatch_tblFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Stopwatch_tblField _setField(
      Stopwatch_tblField? field, String colName, DbType dbtype) {
    return Stopwatch_tblField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Stopwatch_tblField? _id;
  Stopwatch_tblField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  Stopwatch_tblField? _startTime;
  Stopwatch_tblField get startTime {
    return _startTime = _setField(_startTime, 'startTime', DbType.integer);
  }

  Stopwatch_tblField? _endTime;
  Stopwatch_tblField get endTime {
    return _endTime = _setField(_endTime, 'endTime', DbType.integer);
  }

  Stopwatch_tblField? _habitIndex;
  Stopwatch_tblField get habitIndex {
    return _habitIndex = _setField(_habitIndex, 'habitIndex', DbType.integer);
  }

  /// Deletes List<Stopwatch_tbl> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnStopwatch_tbl!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnStopwatch_tbl!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from stopwatch_tbl ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnStopwatch_tbl!.updateBatch(qparams, values);
  }

  /// This method always returns [Stopwatch_tbl] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Stopwatch_tbl?
  @override
  Future<Stopwatch_tbl?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnStopwatch_tbl!.toList(qparams);
    final data = await objFuture;
    Stopwatch_tbl? obj;
    if (data.isNotEmpty) {
      obj = Stopwatch_tbl.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Stopwatch_tbl]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Stopwatch_tbl?
  @override
  Future<Stopwatch_tbl> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Stopwatch_tbl();
  }

  /// This method returns int. [Stopwatch_tbl]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? stopwatch_tblCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final stopwatch_tblsFuture = await _mnStopwatch_tbl!.toList(qparams);
    final int count = stopwatch_tblsFuture[0]['CNT'] as int;
    if (stopwatch_tblCount != null) {
      stopwatch_tblCount(count);
    }
    return count;
  }

  /// This method returns List<Stopwatch_tbl> [Stopwatch_tbl]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Stopwatch_tbl>
  @override
  Future<List<Stopwatch_tbl>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Stopwatch_tbl> stopwatch_tblsData =
        await Stopwatch_tbl.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return stopwatch_tblsData;
  }

  /// This method returns Json String [Stopwatch_tbl]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Stopwatch_tbl]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Stopwatch_tbl]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnStopwatch_tbl!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Stopwatch_tbl]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM stopwatch_tbl WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnStopwatch_tbl!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Stopwatch_tbl]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnStopwatch_tbl!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Stopwatch_tbl.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnStopwatch_tbl!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Stopwatch_tblFilterBuilder

// region Stopwatch_tblFields
class Stopwatch_tblFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fStartTime;
  static TableField get startTime {
    return _fStartTime = _fStartTime ??
        SqlSyntax.setField(_fStartTime, 'startTime', DbType.integer);
  }

  static TableField? _fEndTime;
  static TableField get endTime {
    return _fEndTime =
        _fEndTime ?? SqlSyntax.setField(_fEndTime, 'endTime', DbType.integer);
  }

  static TableField? _fHabitIndex;
  static TableField get habitIndex {
    return _fHabitIndex = _fHabitIndex ??
        SqlSyntax.setField(_fHabitIndex, 'habitIndex', DbType.integer);
  }
}
// endregion Stopwatch_tblFields

//region Stopwatch_tblManager
class Stopwatch_tblManager extends SqfEntityProvider {
  Stopwatch_tblManager()
      : super(SPEND_TIME(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'stopwatch_tbl';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion Stopwatch_tblManager
/// Region SEQUENCE IdentitySequence
class IdentitySequence {
  /// Assigns a new value when it is triggered and returns the new value
  /// returns Future<int>
  Future<int> nextVal([VoidCallback Function(int o)? nextval]) async {
    final val = await SPEND_TIMESequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, true);
    if (nextval != null) {
      nextval(val);
    }
    return val;
  }

  /// Get the current value
  /// returns Future<int>
  Future<int> currentVal([VoidCallback Function(int o)? currentval]) async {
    final val = await SPEND_TIMESequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }

  /// Reset sequence to start value
  /// returns start value
  Future<int> reset([VoidCallback Function(int o)? currentval]) async {
    final val = await SPEND_TIMESequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false, reset: true);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }
}

/// End Region SEQUENCE IdentitySequence

class SPEND_TIMESequenceManager extends SqfEntityProvider {
  SPEND_TIMESequenceManager() : super(SPEND_TIME());
}
// END OF ENTITIES
